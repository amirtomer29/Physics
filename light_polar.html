<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×¡×™××•×œ×˜×•×¨ ×’×œ×™× ×•×§×™×˜×•×‘ - ×’×¨×¤×™×§×” ××©×•×¤×¨×ª</title>
    
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        :root {
            --neon-blue: #00e5ff;
            --neon-green: #00ff99;
            --neon-yellow: #ffcc00;
            --dark-bg: #0a0a0a;
            --panel-bg: #141414;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--dark-bg);
            color: #e0e0e0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding-bottom: 80px;
        }

        h1 { margin: 25px 0 10px 0; font-size: 2rem; color: var(--neon-blue); text-shadow: 0 0 15px rgba(0, 229, 255, 0.6); letter-spacing: 1px; }
        h2 { color: var(--neon-yellow); border-bottom: 2px solid #333; padding-bottom: 10px; margin-top: 50px; width: 90%; font-size: 1.5rem; text-shadow: 0 0 10px rgba(255, 204, 0, 0.3);}

        /* ×§×•× ×˜×™×™× ×¨ ×œ×¡×™××•×œ×¦×™×” */
        .canvas-wrapper {
            width: 90%;
            background: #000;
            border: 1px solid #333;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 229, 255, 0.1);
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }
        
        #wave-container { height: 55vh; }
        #malus-wrapper { height: 450px; }
        
        .overlay-info {
            position: absolute;
            top: 15px; right: 15px;
            background: rgba(0,0,0,0.7);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid #444;
            font-size: 0.85rem;
            color: var(--neon-blue);
            pointer-events: none;
            backdrop-filter: blur(5px);
        }

        /* --- ××–×•×¨ ×ª×™××•×¨×™×” ×•×—×™×©×•×‘×™× --- */
        .theory-section {
            width: 90%;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
            justify-content: center;
        }

        .theory-card {
            flex: 1;
            min-width: 280px;
            background: var(--panel-bg);
            border: 1px solid #333;
            border-right: 4px solid var(--neon-blue);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
        }
        
        .theory-card h3 { margin: 0 0 15px 0; font-size: 1.2rem; color: #fff; display: flex; align-items: center; gap: 10px;}
        .theory-card p, .theory-text p { font-size: 0.95rem; line-height: 1.6; color: #ccc; margin-bottom: 15px; }
        .math-block { direction: ltr; font-family: 'Times New Roman', serif; background: #222; padding: 10px; border-radius: 6px; text-align: center; font-size: 1.1rem; border: 1px solid #444;}

        /* --- ×¡×§×©×Ÿ ×”×× ×¨×’×™×” --- */
        #poynting-container {
            width: 90%;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            background: var(--panel-bg);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #444;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.1);
        }

        #energy-graph-canvas, #energy-visual-canvas {
            background: #080808;
            border: 1px solid #333;
            border-radius: 8px;
            height: 300px;
        }
        #energy-graph-canvas { flex: 2; }
        #energy-visual-canvas { flex: 1; }

        /* ×‘×§×¨×•×ª */
        #controls {
            width: 90%;
            padding: 25px;
            background: var(--panel-bg);
            margin-top: 20px;
            border-radius: 12px;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 25px;
            border: 1px solid #333;
            position: sticky;
            top: 10px;
            z-index: 100;
            box-shadow: 0 10px 20px rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
        }

        .control-group { display: flex; flex-direction: column; min-width: 150px; }
        label { font-weight: bold; font-size: 0.9rem; color: var(--neon-blue); margin-bottom: 8px; letter-spacing: 0.5px;}
        input[type=range] { width: 100%; cursor: pointer; accent-color: var(--neon-blue); height: 6px; background: #333; border-radius: 5px; }
        select { background: #222; color: white; padding: 8px; border: 1px solid #444; border-radius: 6px; outline: none;}
        select:focus { border-color: var(--neon-blue); }

        .math-ltr { direction: ltr; font-family: 'Times New Roman', serif; display: inline-block;}
        .highlight { color: var(--neon-blue); font-weight: bold; }
        .warn { color: #ff4444; font-weight: bold; }
        .good { color: var(--neon-green); font-weight: bold; }
        
        /* ×›×¨×˜×™×¡ ×”×¡×‘×¨ ×××œ×•×¡ */
        #malus-explanation-card {
            border-right-color: var(--neon-green);
            background: #111c11; /* ×¨×§×¢ ×™×¨×§×¨×§ ×¢×“×™×Ÿ ×××•×“ */
        }

    </style>
</head>
<body>

    <h1>×¡×™××•×œ×˜×•×¨ ×’×œ×™× ×•×§×™×˜×•×‘: ×’×¨×¡×” ×’×¨×¤×™×ª ××©×•×¤×¨×ª</h1>
    
    <div id="controls">
        <div class="control-group">
            <label>×ª×‘× ×™×•×ª ××•×›× ×•×ª</label>
            <select id="preset-select">
                <option value="custom">-- ××•×ª×× ××™×©×™×ª --</option>
                <option value="linear-x">×œ×™× ×™××¨×™ (××•×¤×§×™ X)</option>
                <option value="linear-y">×œ×™× ×™××¨×™ (×× ×›×™ Y)</option>
                <option value="linear-45">×œ×™× ×™××¨×™ (45Â°)</option>
                <option value="rcp">××¢×’×œ×™ ×™×× ×™ (RCP)</option>
                <option value="lcp">××¢×’×œ×™ ×©×××œ×™ (LCP)</option>
            </select>
        </div>
        <div class="control-group">
            <label>×××¤×œ×™×˜×•×“×” X ($E_{0x}$)</label>
            <input type="range" id="slider-ex" min="0" max="2" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>×××¤×œ×™×˜×•×“×” Y ($E_{0y}$)</label>
            <input type="range" id="slider-ey" min="0" max="2" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>×”×¤×¨×© ×¤××–×” ($\delta$)</label>
            <input type="range" id="slider-delta" min="-3.14" max="3.14" step="0.157" value="0">
            <span id="delta-val" style="direction:ltr; font-size:0.8rem; color:#aaa; margin-top: 5px;">0 rad</span>
        </div>
        <div class="control-group">
            <label>××”×™×¨×•×ª ×× ×™××¦×™×”</label>
            <input type="range" id="slider-speed" min="0" max="0.2" step="0.01" value="0.05">
        </div>
    </div>

    <div id="polarization-state" style="color:var(--neon-yellow); font-weight:bold; margin:15px; font-size: 1.2rem; text-shadow: 0 0 10px rgba(255,204,0,0.5);">××¦×‘: ×œ×™× ×™××¨×™</div>
    <div class="canvas-wrapper" id="wave-container">
        <div class="overlay-info">ğŸ’¡ ×’×¨×™×¨×” ×œ×¡×‘×¡×•×‘ | ×’×œ×’×œ×ª ×œ×–×•×</div>
    </div>

    <div class="theory-section">
        <div class="theory-card">
            <h3>ğŸ“ ×”××©×•×•××” ×”××ª××˜×™×ª</h3>
            <p>×”×©×“×” ×”×—×©××œ×™ ×”×›×•×œ×œ ×”×•× ×¡×›×•× ×•×§×˜×•×¨×™ ×©×œ ×©× ×™ ×¨×›×™×‘×™× ×××•× ×›×™× ×”××ª×§×“××™× ×‘×¦×™×¨ z:</p>
            <div class="math-block">
                $$ \vec{E}(z,t) = \hat{x} E_{0x}\cos(kz-\omega t) + \hat{y} E_{0y}\cos(kz-\omega t + \delta) $$
            </div>
        </div>

        <div class="theory-card" style="border-right-color: #ff00ff;">
            <h3>ğŸ§® ×™×™×¦×•×’ ×•×§×˜×•×¨ ×’'×•× ×¡</h3>
            <p>×“×¨×š ×§×•××¤×§×˜×™×ª ×œ×™×™×¦×’ ××ª ×”××©×¨×¢×•×ª ×•×”×¤××–×” ×”×™×—×¡×™×ª (×œ×œ× ×ª×œ×•×ª ×‘×–××Ÿ ×•×‘××§×•×):</p>
            <div class="math-block">
                $$ \mathbf{J} = \begin{pmatrix} E_{0x} \\ E_{0y}e^{i\delta} \end{pmatrix} $$
            </div>
        </div>

        <div class="theory-card" style="border-right-color: var(--neon-yellow);">
            <h3>âš¡ ×¢×•×¦××” ×•×•×§×˜×•×¨ ×¤×•×™× ×˜×™× ×’</h3>
            <p>×•×§×˜×•×¨ ×¤×•×™× ×˜×™× ×’ ($\vec{S}$) ××¦×‘×™×¢ ×¢×œ ×›×™×•×•×Ÿ ×–×¨×™××ª ×”×× ×¨×’×™×”. ×”×¢×•×¦××” ($I$) ×”×™× ×××•×¦×¢ ×”×’×•×“×œ ×©×œ×•, ×•×¤×¨×•×¤×•×¨×¦×™×•× ×œ×™×ª ×œ×¨×™×‘×•×¢ ×”×©×“×”:</p>
            <div class="math-block">$$ I \propto |\vec{E}|^2 = E_{0x}^2 + E_{0y}^2 $$</div>
        </div>
    </div>

    <h2>×”×¢××§×”: ×”×× ×¨×’×™×” ×‘×–××Ÿ ×××ª</h2>
    <div id="poynting-container">
        <div class="theory-text" style="flex: 100%;">
            <h3 style="color:var(--neon-blue)">×”×× ×©×˜×£ ×”×× ×¨×’×™×” ×§×‘×•×¢ ××• ×¤×•×¢×?</h3>
            <p>
                ×”×’×¨×¤×™× ××˜×” ××¨××™× ××ª ×”×¢×•×¦××” ×”×¨×’×¢×™×ª $S(t) \propto (E_x(t))^2 + (E_y(t))^2$.
                <br>×©×™××• ×œ×‘ ×œ×”×‘×“×œ ×”×“×¨××˜×™: ×‘×§×™×˜×•×‘ <span class="warn">×œ×™× ×™××¨×™</span> ×”×× ×¨×’×™×” ×™×•×¨×“×ª ×œ××¤×¡ ×¤×¢××™×™× ×‘××—×–×•×¨. ×‘×§×™×˜×•×‘ <span class="good">××¢×’×œ×™</span>, ×‘×–×›×•×ª ×”×–×”×•×ª $\cos^2+\sin^2=1$, ×–×¨×™××ª ×”×× ×¨×’×™×” ×—×œ×§×” ×•×§×‘×•×¢×” ×œ×—×œ×•×˜×™×Ÿ!
            </p>
        </div>
        <div style="flex:2; position:relative;">
            <div style="position:absolute; top:5px; right:10px; font-size:0.8rem; color:#aaa;">×’×¨×£ ×¢×•×¦××” ×¨×’×¢×™×ª (I)</div>
            <canvas id="energy-graph-canvas"></canvas>
        </div>
        <div style="flex:1; position:relative;">
            <div style="position:absolute; top:5px; right:10px; font-size:0.8rem; color:#aaa;">×—×ª×š ×¦×™× ×•×¨ ×”×©×˜×£</div>
            <canvas id="energy-visual-canvas"></canvas>
        </div>
    </div>

    <h2>×—×•×§ ×××œ×•×¡ (Malus's Law) - ×”×“×’××” ×ª×œ×ª ××™××“×™×ª</h2>
    <div class="canvas-wrapper" id="malus-wrapper"></div>
    
    <div style="width:90%; background:var(--panel-bg); padding:20px; border-radius:12px; margin-top:10px; display:flex; gap:30px; align-items:center; border:1px solid #333; box-shadow: 0 5px 15px rgba(0,0,0,0.3);">
        <div style="flex:1">
            <label style="font-size: 1.1rem;">×–×•×•×™×ª ×”×× ×œ×™×™×–×¨ ($\theta$): <span id="angle-display" style="color:var(--neon-yellow);">0</span>Â°</label>
            <input type="range" id="malus-angle" min="0" max="180" step="1" value="0" style="height: 10px; margin-top: 15px;">
        </div>
        <div style="flex:1; text-align:center; background: #000; padding: 15px; border-radius: 8px; border: 2px solid var(--neon-green);">
            <div style="color:#aaa; margin-bottom: 5px;">××—×•×– ×¢×•×¦××” ×¢×•×‘×¨×ª</div>
            <span id="malus-percent" style="font-size:2.2rem; color:var(--neon-green); font-weight: bold; text-shadow: 0 0 15px rgba(0, 255, 153, 0.5);">100%</span>
        </div>
    </div>

    <div class="theory-section">
        <div class="theory-card" id="malus-explanation-card">
            <h3>ğŸ” ×”×¡×‘×¨ ×—×™×©×•×‘: ×—×•×§ ×××œ×•×¡</h3>
            <p>
                ×—×•×§ ×××œ×•×¡ ××ª××¨ ××ª ×”×¢×•×¦××” ×©×œ ××•×¨ ××§×•×˜×‘ ×œ×™× ×™××¨×™×ª ×”×¢×•×‘×¨ ×“×¨×š ××§×˜×‘ ××™×“×™××œ×™.
            </p>
            <div class="math-block" style="font-size: 1.3rem;">
                $$ I_{out} = I_{in} \cdot \cos^2(\theta) $$
            </div>
            <ul style="line-height: 1.8; color: #ccc;">
                <li><b>$I_{in}$</b>: ×¢×•×¦××ª ×”××•×¨ ×”××§×•×˜×‘ ×”×¤×•×’×¢ ×‘××§×˜×‘.</li>
                <li><b>$I_{out}$</b>: ×¢×•×¦××ª ×”××•×¨ ×”×¢×•×‘×¨ ×“×¨×š ×”××§×˜×‘.</li>
                <li><b>$\theta$ (×ª×˜×)</b>: ×”×–×•×•×™×ª ×‘×™×Ÿ ×›×™×•×•×Ÿ ×”×§×™×˜×•×‘ ×©×œ ×”××•×¨ ×”×¤×•×’×¢ ×œ×‘×™×Ÿ ×¦×™×¨ ×”×”×¢×‘×¨×” ×©×œ ×”××§×˜×‘.</li>
            </ul>
            <p style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
                <b>×”×”×™×’×™×•×Ÿ ×”×¤×™×–×™×§×œ×™:</b> ×”××§×˜×‘ ××¢×‘×™×¨ ×¨×§ ××ª ×¨×›×™×‘ ×”×©×“×” ×”×—×©××œ×™ ×©××§×‘×™×œ ×œ×¦×™×¨ ×©×œ×•. ×¨×›×™×‘ ×–×” ×”×•× $E_{out} = E_{in}\cos(\theta)$. ××›×™×•×•×Ÿ ×©×”×¢×•×¦××” ×¤×¨×•×¤×•×¨×¦×™×•× ×œ×™×ª ×œ×¨×™×‘×•×¢ ×”×©×“×” ($I \propto E^2$), ×”×¢×•×¦××” ×ª×œ×•×™×” ×‘×§×•×¡×™× ×•×¡ ×‘×¨×™×‘×•×¢ ×”×–×•×•×™×ª.
            </p>
        </div>
    </div>


    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ××©×ª× ×™× ×’×œ×•×‘×œ×™×™× ×œ×¡×™××•×œ×¦×™×”
        let params = { ex: 1.0, ey: 1.0, delta: 0, k: 0.3, omega: 0.05, time: 0 };

        // ==========================================
        // 1. ×¡×™××•×œ×˜×•×¨ ×’×œ×™× 3D (×’×¨×¤×™×§×” ××©×•×¤×¨×ª)
        // ==========================================
        const waveContainer = document.getElementById('wave-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02); // ×¢×¨×¤×œ ×œ×¢×•××§

        const camera = new THREE.PerspectiveCamera(45, waveContainer.clientWidth / waveContainer.clientHeight, 0.1, 1000);
        camera.position.set(25, 12, 35);
        camera.lookAt(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(waveContainer.clientWidth, waveContainer.clientHeight);
        renderer.setClearColor(0x000000);
        waveContainer.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- ×ª××•×¨×” ---
        const ambientLight = new THREE.AmbientLight(0x444444);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0x00e5ff, 1, 100);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        // --- ×¢×–×¨×™× ---
        const gridHelper = new THREE.GridHelper(80, 80, 0x333333, 0x111111);
        gridHelper.position.y = -6; 
        scene.add(gridHelper);

        // --- ×™×¦×™×¨×ª ×”×’×œ×™× ---
        const arrows = [];
        const zCount = 60; const zLen = 40;
        
        // ×—×•××¨×™× ×–×•×”×¨×™×
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, linewidth: 3 });
        
        for(let i=0; i<zCount; i++) {
            const z = (i / zCount) * zLen;
            const origin = new THREE.Vector3(0, 0, z);
            // ×—×¥ ×©×§×•×œ ×¨××©×™ - ×¦×‘×¢ × ×™××•×Ÿ
            const arrowRes = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), origin, 0, 0x00e5ff, 0.5, 0.3);
            scene.add(arrowRes);
            arrows.push({ z, arrowRes });
        }
        
        const lineGeo = new THREE.BufferGeometry();
        const waveLine = new THREE.Line(lineGeo, lineMat);
        scene.add(waveLine);

        function updateWave3D() {
            const points = [];
            arrows.forEach(item => {
                const angleX = params.k * item.z - params.time;
                const angleY = params.k * item.z - params.time + params.delta;
                
                const valX = params.ex * Math.cos(angleX);
                const valY = params.ey * Math.cos(angleY);
                
                const vec = new THREE.Vector3(valX, valY, 0);
                const len = vec.length();
                
                if (len > 0.05) {
                    item.arrowRes.visible = true;
                    // ××•×¨×š ×”×—×¥
                    item.arrowRes.setLength(len, 0.5, 0.3);
                    item.arrowRes.setDirection(vec.normalize());
                    // ×©×™× ×•×™ ×¦×‘×¢ ×“×™× ××™ ×§×œ ×œ×¤×™ ×”××•×¨×š
                    const intensity = Math.min(len / 2, 1);
                    item.arrowRes.setColor(new THREE.Color().setHSL(0.5 + intensity*0.1, 1, 0.5));

                } else {
                    item.arrowRes.visible = false;
                }
                points.push(valX, valY, item.z);
            });
            waveLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
        }

        // ==========================================
        // 2. ×¡×™××•×œ×˜×•×¨ ×× ×¨×’×™×” (2D Canvas)
        // ==========================================
        const graphCanvas = document.getElementById('energy-graph-canvas');
        const visualCanvas = document.getElementById('energy-visual-canvas');
        const gCtx = graphCanvas.getContext('2d');
        const vCtx = visualCanvas.getContext('2d');

        function resize2D() {
            graphCanvas.width = graphCanvas.clientWidth; graphCanvas.height = graphCanvas.clientHeight;
            visualCanvas.width = visualCanvas.clientWidth; visualCanvas.height = visualCanvas.clientHeight;
        }
        window.addEventListener('resize', resize2D);
        resize2D();

        const intensityHistory = [];

        function updateEnergySim() {
            const angleX = -params.time; 
            const angleY = -params.time + params.delta;
            const Ex = params.ex * Math.cos(angleX);
            const Ey = params.ey * Math.cos(angleY);
            const instantIntensity = Ex*Ex + Ey*Ey;
            
            intensityHistory.push(instantIntensity);
            if(intensityHistory.length > graphCanvas.width) intensityHistory.shift();

            // --- ×’×¨×£ ---
            const w = graphCanvas.width; const h = graphCanvas.height;
            gCtx.clearRect(0,0,w,h);
            
            // ×§×•×•×™ ×¨×©×ª
            gCtx.strokeStyle = "#333"; gCtx.lineWidth = 1; gCtx.beginPath();
            gCtx.moveTo(0, h*0.25); gCtx.lineTo(w, h*0.25);
            gCtx.moveTo(0, h*0.5); gCtx.lineTo(w, h*0.5);
            gCtx.moveTo(0, h*0.75); gCtx.lineTo(w, h*0.75);
            gCtx.stroke();

            gCtx.strokeStyle = "#00ff99"; gCtx.lineWidth = 3; gCtx.beginPath();
            gCtx.shadowColor = "#00ff99"; gCtx.shadowBlur = 10;
            
            const scaleY = h / 9; 
            for(let i=0; i<intensityHistory.length; i++) {
                const val = intensityHistory[i];
                const x = w - (intensityHistory.length - i)*2; 
                const y = h - (val * scaleY) - 20;
                if(i===0) gCtx.moveTo(x, y); else gCtx.lineTo(x, y);
            }
            gCtx.stroke();
            gCtx.shadowBlur = 0;

            // --- ×•×™×–×•××œ×™×–×¦×™×” ---
            const vw = visualCanvas.width; const vh = visualCanvas.height;
            vCtx.clearRect(0,0,vw,vh);
            const radius = Math.sqrt(instantIntensity) * 35;
            const cx = vw/2; const cy = vh/2;

            const grad = vCtx.createRadialGradient(cx, cy, 0, cx, cy, radius + 30);
            grad.addColorStop(0, "rgba(0, 229, 255, 0.8)");
            grad.addColorStop(0.4, "rgba(0, 229, 255, 0.2)");
            grad.addColorStop(1, "rgba(0, 0, 0, 0)");

            vCtx.fillStyle = grad; vCtx.beginPath(); vCtx.arc(cx, cy, radius + 20, 0, Math.PI*2); vCtx.fill();
            vCtx.strokeStyle = "#fff"; vCtx.lineWidth = 3; vCtx.beginPath(); vCtx.arc(cx, cy, radius, 0, Math.PI*2); vCtx.stroke();
        }

        // ==========================================
        // 3. ×¡×™××•×œ×˜×•×¨ ×××œ×•×¡ 3D (×’×¨×¤×™×§×” ××©×•×¤×¨×ª)
        // ==========================================
        const malusContainer = document.getElementById('malus-wrapper');
        const mScene = new THREE.Scene();
        mScene.background = new THREE.Color(0x0a0a0a);
        const mCamera = new THREE.PerspectiveCamera(50, malusContainer.clientWidth / malusContainer.clientHeight, 0.1, 100);
        mCamera.position.set(0, 10, 25);
        const mRenderer = new THREE.WebGLRenderer({ antialias: true });
        mRenderer.setSize(malusContainer.clientWidth, malusContainer.clientHeight);
        malusContainer.appendChild(mRenderer.domElement);
        const mControls = new OrbitControls(mCamera, mRenderer.domElement);
        mControls.enableDamping = true;

        // ×ª××•×¨×” ×œ×××œ×•×¡
        const mAmbient = new THREE.AmbientLight(0x555555);
        mScene.add(mAmbient);
        const mLight1 = new THREE.PointLight(0xffffff, 2, 50);
        mLight1.position.set(-10, 10, 10);
        mScene.add(mLight1);

        // ×—×•××¨×™× ××©×•×¤×¨×™× ×œ××§×˜×‘×™× (××‘×¨×™×§×™× ×•×©×§×•×¤×™×)
        const polMaterialGreen = new THREE.MeshPhongMaterial({ 
            color: 0x00ff00, opacity: 0.4, transparent: true, shininess: 100, specular: 0xffffff, side: THREE.DoubleSide 
        });
        const polMaterialGold = new THREE.MeshPhongMaterial({ 
            color: 0xffcc00, opacity: 0.4, transparent: true, shininess: 100, specular: 0xffffff, side: THREE.DoubleSide 
        });

        const polGeo = new THREE.BoxGeometry(0.2, 6, 6);
        
        // ××§×˜×‘ 1
        const p1 = new THREE.Group();
        p1.add(new THREE.Mesh(polGeo, polMaterialGreen));
        const p1Frame = new THREE.LineSegments(new THREE.EdgesGeometry(polGeo), new THREE.LineBasicMaterial({color:0x88ff88}));
        p1.add(p1Frame);
        for(let i=-2.5; i<=2.5; i+=0.8) {
             const lineG = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0.12, -2.8, i), new THREE.Vector3(0.12, 2.8, i)]);
             p1.add(new THREE.Line(lineG, new THREE.LineBasicMaterial({color:0xccffcc})));
        }
        p1.position.x = -8;
        mScene.add(p1);
        
        // ××§×˜×‘ 2
        const p2 = new THREE.Group();
        p2.add(new THREE.Mesh(polGeo, polMaterialGold));
        const p2Frame = new THREE.LineSegments(new THREE.EdgesGeometry(polGeo), new THREE.LineBasicMaterial({color:0xffee88}));
        p2.add(p2Frame);
        for(let i=-2.5; i<=2.5; i+=0.8) {
             const lineG = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0.12, -2.8, i), new THREE.Vector3(0.12, 2.8, i)]);
             p2.add(new THREE.Line(lineG, new THREE.LineBasicMaterial({color:0xffffcc})));
        }
        p2.position.x = 8;
        mScene.add(p2);

        // ×§×¨×Ÿ ××•×¨ (×¢×‘×” ×™×•×ª×¨ ×•×–×•×”×¨×ª)
        const beamCount = 300;
        const beamGeo = new THREE.BufferGeometry();
        beamGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(beamCount * 3), 3));
        const beamMat = new THREE.LineBasicMaterial({color:0x00ff99, linewidth: 4});
        const beamLine = new THREE.Line(beamGeo, beamMat);
        mScene.add(beamLine);

        let malusAngle = 0;

        function updateMalus3D() {
            const rad = malusAngle * (Math.PI / 180);
            p2.rotation.x = rad; 

            const positions = beamLine.geometry.attributes.position.array;
            const transmission = Math.cos(rad);

            for(let i=0; i<beamCount; i++) {
                const x = -18 + (i/beamCount)*36; 
                const t = -params.time * 6 + x*1.5;
                
                positions[i*3] = x;
                
                // ×œ×¤× ×™ ××§×˜×‘ 1 (×× ×›×™)
                let ampY = 2 * Math.cos(t);
                let ampZ = 0;

                // ×‘×™×Ÿ ×”××§×˜×‘×™× (× ×©××¨ ×× ×›×™)
                if (x > -8) { }

                // ××—×¨×™ ××§×˜×‘ 2 (×—×•×§ ×××œ×•×¡)
                if (x > 8) {
                    const val = 2 * transmission * Math.cos(t); 
                    ampY = val * Math.cos(rad);
                    ampZ = val * Math.sin(rad);
                }
                positions[i*3+1] = ampY;
                positions[i*3+2] = ampZ;
            }
            beamLine.geometry.attributes.position.needsUpdate = true;
            
            // ×©×™× ×•×™ ×¦×‘×¢ ×”×§×¨×Ÿ ×‘×™×¦×™××” ×œ×¤×™ ×”×¢×•×¦××”
            const intensity = Math.abs(transmission);
            beamLine.material.color.setHSL(0.35, 1, 0.3 + intensity*0.4); // ××›×”×” ×œ×‘×”×™×¨
        }


        // ==========================================
        // ×œ×•×œ××ª ×× ×™××¦×™×” ×¨××©×™×ª
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);
            params.time += params.omega;
            updateWave3D(); controls.update(); renderer.render(scene, camera);
            updateEnergySim();
            updateMalus3D(); mControls.update(); mRenderer.render(mScene, mCamera);
        }
        animate();


        // ==========================================
        // ×××©×§ ××©×ª××© (DOM)
        // ==========================================
        const sEx = document.getElementById('slider-ex');
        const sEy = document.getElementById('slider-ey');
        const sDelta = document.getElementById('slider-delta');
        const sSpeed = document.getElementById('slider-speed');
        const sPreset = document.getElementById('preset-select');
        const lDelta = document.getElementById('delta-val');
        const lState = document.getElementById('polarization-state');

        function updateWaveParams() {
            params.ex = parseFloat(sEx.value);
            params.ey = parseFloat(sEy.value);
            params.delta = parseFloat(sDelta.value);
            params.omega = parseFloat(sSpeed.value);

            const piFrac = params.delta / Math.PI;
            lDelta.textContent = (piFrac===0 ? "0" : piFrac.toFixed(2) + "Ï€") + " rad";

            const d = Math.abs(params.delta);
            const eq = Math.abs(params.ex - params.ey) < 0.1;
            
            if (params.ex < 0.1 || params.ey < 0.1 || d < 0.1 || Math.abs(d-Math.PI) < 0.1) {
                lState.innerText = "××¦×‘: ×œ×™× ×™××¨×™ (×©×˜×£ ×¤×•×¢×)"; lState.style.color = "#ff4444";
            } else if (eq && Math.abs(d - Math.PI/2) < 0.1) {
                lState.innerText = "××¦×‘: ××¢×’×œ×™ (×©×˜×£ ×§×‘×•×¢!)"; lState.style.color = "#00ff99";
            } else {
                lState.innerText = "××¦×‘: ××œ×™×¤×˜×™ (×©×˜×£ ××ª× ×•×“×“)"; lState.style.color = "var(--neon-blue)";
            }
        }

        const sMalus = document.getElementById('malus-angle');
        const lMalusAng = document.getElementById('angle-display');
        const lMalusPct = document.getElementById('malus-percent');

        sMalus.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            malusAngle = val;
            lMalusAng.textContent = val;
            const rad = val * Math.PI / 180;
            const pct = Math.pow(Math.cos(rad), 2) * 100;
            lMalusPct.textContent = pct.toFixed(0) + "%";
            
            // ×©×™× ×•×™ ×¦×‘×¢ ×”××—×•×–×™×
            const hue = (pct / 100) * 120; // ××“×•× ×œ×™×¨×•×§
            lMalusPct.style.color = `hsl(${hue}, 100%, 50%)`;
            lMalusPct.style.textShadow = `0 0 15px hsl(${hue}, 100%, 50%)`;
        });

        [sEx, sEy, sDelta, sSpeed].forEach(el => el.addEventListener('input', updateWaveParams));
        sPreset.addEventListener('change', (e) => {
            const v = e.target.value;
            if (v==='linear-x') { sEx.value=1.5; sEy.value=0; sDelta.value=0; }
            if (v==='linear-y') { sEx.value=0; sEy.value=1.5; sDelta.value=0; }
            if (v==='linear-45') { sEx.value=1; sEy.value=1; sDelta.value=0; }
            if (v==='rcp') { sEx.value=1; sEy.value=1; sDelta.value=-Math.PI/2; }
            if (v==='lcp') { sEx.value=1; sEy.value=1; sDelta.value=Math.PI/2; }
            updateWaveParams();
        });

        window.addEventListener('resize', () => {
            const w = waveContainer.clientWidth; const h = waveContainer.clientHeight;
            camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h);
            const mw = malusContainer.clientWidth; const mh = malusContainer.clientHeight;
            mCamera.aspect = mw/mh; mCamera.updateProjectionMatrix(); mRenderer.setSize(mw,mh);
            resize2D();
        });

        updateWaveParams();

    </script>
</body>
</html>